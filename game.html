<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Простая RPG</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Темный фон */
            color: #e2e8f0; /* Светлый текст */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .game-container {
            position: relative;
            display: flex;
            flex-direction: column; /* По умолчанию колонками для маленьких экранов */
            gap: 24px; /* Увеличенный отступ */
            background: linear-gradient(145deg, #2d3748, #1a202c); /* Современный градиент */
            padding: 32px; /* Увеличенный отступ */
            border-radius: 16px; /* Более скругленные углы */
            box-shadow: 0 15px 25px rgba(0, 0, 0, 0.5); /* Более выраженная тень */
            max-width: 1000px; /* Увеличена максимальная ширина */
            width: 100%;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(74, 85, 104, 0.5); /* Мягкая рамка */
        }
        canvas {
            background-color: #000;
            border: 2px solid #4a5568;
            border-radius: 10px; /* Скругленные углы для канваса */
            display: block;
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1 / 1;
            margin: 0 auto;
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4);
        }
        .game-info, .message-log {
            background-color: #2d3748;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #4a5568;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease-in-out; /* Плавный переход */
        }
        .game-info:hover, .message-log:hover {
            transform: translateY(-3px); /* Легкий эффект при наведении */
        }
        .game-info h2 {
            font-size: 1.4rem; /* Увеличенный размер шрифта */
            font-weight: 700; /* Более жирный */
            color: #90cdf4; /* Более яркий синий */
            margin-bottom: 10px;
            text-shadow: 0 0 5px rgba(144, 205, 244, 0.3); /* Легкая тень для заголовка */
        }
        .game-info p {
            font-size: 1.05rem; /* Немного увеличенный размер шрифта */
            color: #cbd5e0;
            line-height: 1.5;
            word-break: break-word; /* Перенос длинных слов */
        }
        .message-log {
            min-height: 120px; /* Увеличенная минимальная высота */
            max-height: 250px; /* Увеличенная максимальная высота */
            font-size: 0.95rem;
            color: #a0aec0;
            overflow-y: auto;
            scrollbar-width: thin; /* Тонкий скроллбар для Firefox */
            scrollbar-color: #4a5568 #2d3748; /* Цвет скроллбара */
        }
        .message-log::-webkit-scrollbar {
            width: 8px; /* Ширина скроллбара для Webkit */
        }
        .message-log::-webkit-scrollbar-track {
            background: #2d3748; /* Фон трека скроллбара */
            border-radius: 10px;
        }
        .message-log::-webkit-scrollbar-thumb {
            background-color: #4a5568; /* Цвет ползунка скроллбара */
            border-radius: 10px;
            border: 2px solid #2d3748;
        }
        .message-log p {
            margin: 0;
            padding: 4px 0;
            border-bottom: 1px dashed rgba(74, 85, 104, 0.3); /* Разделитель сообщений */
            word-break: break-word; /* Перенос длинных слов в логе */
        }
        .message-log p:last-child {
            border-bottom: none;
        }
        .controls {
            display: flex;
            flex-wrap: wrap; /* Перенос кнопок на новую строку */
            justify-content: center;
            gap: 12px; /* Увеличенный отступ между кнопками */
            margin-top: 15px;
        }
        .control-button {
            background: linear-gradient(90deg, #4299e1, #63b3ed); /* Градиент для кнопок */
            color: white;
            padding: 12px 20px; /* Увеличенный padding */
            border-radius: 10px; /* Скругленные углы */
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease; /* Плавный переход для всех свойств */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3); /* Более выраженная тень */
            border: none; /* Убираем стандартную рамку */
            text-transform: uppercase; /* Заглавные буквы */
            letter-spacing: 0.5px; /* Небольшой интервал между буквами */
        }
        .control-button:hover {
            background: linear-gradient(90deg, #3182ce, #4299e1); /* Изменение градиента при наведении */
            transform: translateY(-2px) scale(1.02); /* Небольшое поднятие и увеличение */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }
        .control-button:active {
            transform: translateY(0) scale(0.98); /* Эффект нажатия */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            .game-container {
                flex-direction: row;
                align-items: flex-start;
                justify-content: space-between;
                padding: 40px; /* Еще больше отступа на больших экранах */
            }
            .game-main {
                flex: 2;
                display: flex;
                flex-direction: column;
                gap: 24px;
                flex-shrink: 0;
                min-width: 0;
            }
            .game-sidebar {
                flex: 1;
                min-width: 280px; /* Увеличена минимальная ширина боковой панели */
                max-width: 350px; /* Ограничение максимальной ширины */
                display: flex;
                flex-direction: column;
                gap: 24px;
                flex-shrink: 0;
            }
        }

        /* Loading overlay styles */
        #loadingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9); /* Более темный фон для загрузки */
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5em; /* Увеличенный размер шрифта */
            font-weight: bold;
            z-index: 100;
            border-radius: 16px; /* Соответствует контейнеру */
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); /* Тень для текста загрузки */
            pointer-events: auto; /* Allow interaction with the overlay */
        }
        /* No .hidden class needed anymore, direct style manipulation */
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-main">
            <canvas id="gameCanvas"></canvas>
            <div id="loadingOverlay">Загрузка...</div>
            <div class="message-log" id="messageLog">
                <p>Добро пожаловать в подземелье!</p>
            </div>
            <div class="controls">
                <button class="control-button" onclick="movePlayer(0, -1)">Вверх</button>
                <button class="control-button" onclick="movePlayer(0, 1)">Вниз</button>
                <button class="control-button" onclick="movePlayer(-1, 0)">Влево</button>
                <button class="control-button" onclick="movePlayer(1, 0)">Вправо</button>
                <button class="control-button" onclick="recreateDungeon()">Пересоздать подземелье</button>
            </div>
        </div>
        <div class="game-sidebar">
            <div class="game-info">
                <h2>Игрок</h2>
                <p>ID: <span id="playerID"></span></p>
                <p>Здоровье: <span id="playerHealth">100</span></p>
                <p>Атака: <span id="playerAttack">10</span></p>
                <p>Защита: <span id="playerDefense">5</span></p>
                <p>Опыт: <span id="playerXP">0</span></p>
                <p>Уровень: <span id="playerLevel">1</span></p>
            </div>
            <div class="game-info">
                <h2>Инвентарь</h2>
                <ul id="inventoryList" class="list-disc list-inside">
                    <li>Пусто</li>
                </ul>
            </div>
            <div class="game-info">
                <h2>Текущая локация</h2>
                <p>X: <span id="playerX">0</span>, Y: <span id="playerY">0</span></p>
                <p>Чанк: (<span id="playerChunkX">0</span>, <span id="playerChunkY">0</span>)</p>
            </div>
            <div class="game-info">
                <h2>Другие игроки</h2>
                <ul id="otherPlayersList" class="list-disc list-inside">
                    <li>Нет других игроков</li>
                </ul>
            </div>
        </div>
    </div>

    <script type="module">
        // Supabase imports
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.50.0/+esm';

        // Supabase configuration - Use global variables if provided by the environment, otherwise use hardcoded values
        const SUPABASE_URL = typeof __supabase_url !== 'undefined' ? __supabase_url : 'https://kbjlqmzeclrtowtygbvu.supabase.co';
        const SUPABASE_ANON_KEY = typeof __supabase_anon_key !== 'undefined' ? __supabase_anon_key : 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtiamxxbXplY2xydG93dHlnYnZ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc4NTU2ODksImV4cCI6MjA2MzQzMTY4OX0.17nwxPRZnSMzwSbtAo83bxFEFWP5rdhjhUNuxxLLGP8';

        let supabase = null; // Initialize as null
        let userId = null; // Initialize as null
        let gameReady = false; // Indicates if the local game is ready to play

        // Game configuration
        const TILE_SIZE = 40;
        const MAP_WIDTH = 15;
        const MAP_HEIGHT = 15;

        // Global constants for the central hub
        const HUB_WIDTH = 7;
        const HUB_HEIGHT = 7;
        const HUB_X = Math.floor((MAP_WIDTH - HUB_WIDTH) / 2);
        const HUB_Y = Math.floor((MAP_HEIGHT - HUB_HEIGHT) / 2);

        // Game state
        let player = {
            id: crypto.randomUUID(), // Assign a random ID by default for local play
            name: 'Игрок', // Will be updated to 'Игрок <ID>' or 'Локальный Игрок <ID>'
            x: 0,
            y: 0,
            chunkX: 0, // Координата чанка по X
            chunkY: 0, // Координата чанка по Y
            health: 100,
            maxhealth: 100,
            attack: 10,
            defense: 5,
            xp: 0,
            level: 1,
            inventory: []
        };

        let map = []; // 2D массив, представляющий карту игры (общий)
        let enemies = []; // Массив для хранения объектов врагов (общий)
        let otherPlayers = [];

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const loadingOverlay = document.getElementById('loadingOverlay');

        canvas.width = MAP_WIDTH * TILE_SIZE;
        canvas.height = MAP_HEIGHT * TILE_SIZE;

        // Player image
        const playerImage = new Image();
        playerImage.src = 'https://www.speedrun.com/static/user/j5wngezj/icon.png';
        playerImage.isLoaded = false;
        playerImage.onload = () => {
            console.log("Player image loaded successfully!");
            playerImage.isLoaded = true;
            if (gameReady) {
                drawGame();
            }
        };
        playerImage.onerror = () => {
            console.error("Failed to load player image. Using fallback square.");
            playerImage.isLoaded = false;
            if (gameReady) {
                drawGame();
            }
        };

        // Wall image
        const wallImage = new Image();
        wallImage.src = 'https://avatars.mds.yandex.net/i?id=6a5d210fb5031e640a1b963ed342663f-2414590-images-thumbs&n=13';
        wallImage.isLoaded = false;
        wallImage.onload = () => {
            console.log("Wall image loaded successfully!");
            wallImage.isLoaded = true;
            if (gameReady) {
                drawGame();
            }
        };
        wallImage.onerror = () => {
            console.error("Failed to load wall image. Using fallback color.");
            wallImage.isLoaded = false;
            if (gameReady) {
                drawGame();
            }
        };

        // Goblin image
        const goblinImage = new Image();
        goblinImage.src = 'https://d3iuzwoiyg9qa8.cloudfront.net/webadmin/storage/public/airdrops/small-thumbnail/TfBu8Q0hjdEKPn7GBenK6U9RVXoM7khs0cC2XGjf.webp';
        goblinImage.isLoaded = false;
        goblinImage.onload = () => {
            console.log("Goblin image loaded successfully!");
            goblinImage.isLoaded = true;
            if (gameReady) {
                drawGame();
            }
        };
        goblinImage.onerror = () => {
            console.error("Failed to load goblin image. Using fallback red square.");
            goblinImage.isLoaded = false;
            if (gameReady) {
                drawGame();
            }
        };

        // UI elements
        const playerIDEl = document.getElementById('playerID');
        const playerHealthEl = document.getElementById('playerHealth'); 
        const playerAttackEl = document.getElementById('playerAttack'); 
        const playerDefenseEl = document.getElementById('playerDefense');
        const playerXPEl = document.getElementById('playerXP');
        const playerLevelEl = document.getElementById('playerLevel');
        const playerXEl = document.getElementById('playerX');
        const playerYEl = document.getElementById('playerY');
        const playerChunkXEl = document.getElementById('playerChunkX'); // Новый элемент для отображения чанка X
        const playerChunkYEl = document.getElementById('playerChunkY'); // Новый элемент для отображения чанка Y
        const inventoryListEl = document.getElementById('inventoryList');
        const messageLogEl = document.getElementById('messageLog');
        const otherPlayersListEl = document.getElementById('otherPlayersList');

        /**
         * Attempts to initialize Supabase client and authenticate the user (anonymously).
         * Sets `supabase` and `userId` if successful. Throws error on failure.
         */
        async function initializeSupabaseConnection() {
            console.log("Attempting to create Supabase client...");
            supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            console.log("Supabase client created.");
            
            console.log("Attempting to get Supabase session or sign in anonymously...");
            const { data: { session }, error: getSessionError } = await supabase.auth.getSession();

            if (getSessionError) {
                console.error("DEBUG: Full getSessionError object:", getSessionError);
                console.error("Ошибка получения сессии:", getSessionError);
                logMessage("Ошибка получения сессии. Попытка анонимного входа...");
                const { error: signInError } = await supabase.auth.signInAnonymously();
                if (signInError) {
                    throw signInError; // Re-throw to be caught by the outer catch block
                } else {
                    console.log("Анонимный вход успешно инициирован.");
                }
            } else if (!session) {
                console.log("Нет активной сессии. Попытка анонимного входа...");
                const { error: signInError } = await supabase.auth.signInAnonymously();
                if (signInError) {
                    throw signInError; // Re-throw to be caught by the outer catch block
                } else {
                    console.log("Анонимный вход успешно инициирован.");
                }
            } else {
                console.log("Существует активная сессия, пользователь:", session.user.id);
            }

            // If we reached here, Supabase auth was successful
            const user = (await supabase.auth.getUser()).data.user; // Get user after potential sign-in
            userId = user.id;
            player.id = userId; // Update player ID to Supabase ID
            player.name = `Игрок ${userId.substring(0, 6)}`; // Update player name
            playerIDEl.textContent = userId; // Update UI with Supabase ID
            logMessage(`Вы вошли как: ${player.name}`);
            console.log("Supabase connection and authentication successful.");
        }

        /**
         * Sets up online-specific game features (loading/saving data, real-time listeners).
         * This is called ONLY if Supabase connection is successful.
         */
        async function setupOnlineGameFeatures() {
            if (!supabase || !userId) {
                console.warn("Supabase not available, skipping online game features setup.");
                return;
            }
            console.log("Setting up online game features...");

            // 1. Load or initialize global game state (map and enemies) from Supabase
            await loadOrCreateGameState();

            // 2. Load or initialize player data from Supabase
            const { data: existingPlayer, error: fetchPlayerError } = await supabase
                .from('players')
                .select('*')
                .eq('id', player.id)
                .single();

            if (fetchPlayerError && fetchPlayerError.code !== 'PGRST116') {
                console.error("Ошибка загрузки данных игрока из Supabase:", fetchPlayerError);
                logMessage("Ошибка загрузки вашего прогресса из Supabase.");
            } else if (existingPlayer) {
                player.x = existingPlayer.x;
                player.y = existingPlayer.y;
                player.chunkX = existingPlayer.chunkX || 0;
                player.chunkY = existingPlayer.chunkY || 0;
                player.health = existingPlayer.health;
                player.maxhealth = existingPlayer.maxhealth;
                player.attack = existingPlayer.attack;
                player.defense = existingPlayer.defense;
                player.xp = existingPlayer.xp;
                player.level = existingPlayer.level;
                logMessage("Ваш прогресс загружен из Supabase.");
            } else {
                await updatePlayerPositionInSupabase(); // Insert initial player state
                logMessage("Новый профиль игрока создан в Supabase.");
            }

            // 3. Set up real-time listeners
            await listenForOtherPlayers();
            listenForGameStateChanges();
            logMessage("Онлайн-функции активированы.");
            updateUI(); // Final UI update after online features are set up
        }

        /**
         * Gets the current world ID based on player's chunk coordinates.
         * @returns {string} Уникальный ID для текущего чанка мира.
         */
        function getCurrentWorldId() {
            return `world_${player.chunkX}_${player.chunkY}`;
        }

        /**
         * Loads global game state (map and enemies) from Supabase, or creates it if not found.
         */
        async function loadOrCreateGameState() {
            // Only attempt to load/save from Supabase if it's initialized
            if (!supabase || !userId) {
                console.warn("Supabase not available, loading game state locally.");
                initializeMap(); // Ensure map is initialized even in local mode
                spawnEnemies(); // Ensure enemies are spawned even in local mode
                return;
            }

            console.log(`Attempting to load game state for chunk ${getCurrentWorldId()} from Supabase...`);
            const { data, error } = await supabase
                .from('game_state')
                .select('*')
                .eq('id', getCurrentWorldId()) // Использовать динамический ID
                .single();

            if (error && error.code !== 'PGRST116') { // PGRST116 означает "строки не найдены"
                console.error("Ошибка загрузки глобального состояния игры:", error);
                logMessage("Ошибка загрузки мира.");
                // Fallback: инициализировать локально, если загрузка не удалась
                initializeMap(); // Это теперь вызовет generateDungeon
                spawnEnemies();
                await updateGameStateInSupabase(); // Попытаться сохранить вновь сгенерированное состояние
            } else if (data) {
                console.log("Global game state loaded:", data);
                map = JSON.parse(data.map_data);
                enemies = JSON.parse(data.enemies_data);
                logMessage(`Мир ${getCurrentWorldId()} загружен.`);
            } else {
                console.log(`No existing game state found for chunk ${getCurrentWorldId()}. Initializing new world...`);
                initializeMap(); // Это теперь вызовет generateDungeon
                spawnEnemies();
                await updateGameStateInSupabase(); // Сохранить вновь сгенерированное состояние
                logMessage(`Новый мир ${getCurrentWorldId()} создан.`);
            }
        }

        /**
         * Initializes the game map with a procedural dungeon.
         */
        function initializeMap() {
            map = []; // Убедиться, что карта пуста перед заполнением
            for (let y = 0; y < MAP_HEIGHT; y++) {
                map[y] = [];
                for (let x = 0; x < MAP_WIDTH; x++) {
                    map[y][x] = 'wall'; // Начать со всех стен
                }
            }
            generateDungeon(); // Вызвать новую функцию генерации подземелья
            // ensureExits() is no longer needed as the hub corridors guarantee exits
            console.log("Map initialized locally with dungeon:", map);
        }

        // --- Dungeon Generation Logic with Central Hub ---
        function generateDungeon() {
            // 1. Initialize map with all walls (already done in initializeMap, but good for clarity)
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    map[y][x] = 'wall';
                }
            }

            const rooms = [];

            // 2. Define and carve out the central hub
            const hub = {
                x: HUB_X,
                y: HUB_Y,
                width: HUB_WIDTH,
                height: HUB_HEIGHT
            };
            rooms.push(hub); // Add hub to rooms list for overlap checks

            for (let y = hub.y; y < hub.y + hub.height; y++) {
                for (let x = hub.x; x < hub.x + hub.width; x++) {
                    map[y][x] = 'floor';
                }
            }

            // 3. Carve out four main corridors from the hub to the edges
            const hubCenterX = Math.floor(hub.x + hub.width / 2);
            const hubCenterY = Math.floor(hub.y + hub.height / 2);

            // North corridor
            for (let y = 0; y < hub.y + 1; y++) {
                map[y][hubCenterX] = 'floor';
            }
            // South corridor
            for (let y = hub.y + hub.height - 1; y < MAP_HEIGHT; y++) {
                map[y][hubCenterX] = 'floor';
            }
            // West corridor
            for (let x = 0; x < hub.x + 1; x++) {
                map[hubCenterY][x] = 'floor';
            }
            // East corridor
            for (let x = hub.x + hub.width - 1; x < MAP_WIDTH; x++) {
                map[hubCenterY][x] = 'floor';
            }

            // 4. Set player spawn to the center of the hub
            player.x = hubCenterX;
            player.y = hubCenterY;

            // 5. Generate additional random rooms (avoiding the hub and main corridors)
            const NUM_ADDITIONAL_ROOMS = Math.floor(Math.random() * 2) + 2; // 2-3 additional rooms
            const MIN_ROOM_SIZE = 3;
            const MAX_ROOM_SIZE = 7;

            for (let i = 0; i < NUM_ADDITIONAL_ROOMS; i++) {
                let newRoom;
                let overlaps;
                let attempts = 0;
                const maxAttempts = 100;

                do {
                    overlaps = false;
                    const rw = Math.floor(Math.random() * (MAX_ROOM_SIZE - MIN_ROOM_SIZE + 1)) + MIN_ROOM_SIZE;
                    const rh = Math.floor(Math.random() * (MAX_ROOM_SIZE - MIN_ROOM_SIZE + 1)) + MIN_ROOM_SIZE;
                    const rx = Math.floor(Math.random() * (MAP_WIDTH - rw));
                    const ry = Math.floor(Math.random() * (MAP_HEIGHT - rh));

                    newRoom = { x: rx, y: ry, width: rw, height: rh };

                    // Check for overlaps with all existing rooms (including the hub)
                    for (const existingRoom of rooms) {
                        // Add a small buffer to avoid rooms being right next to each other
                        if (
                            newRoom.x < existingRoom.x + existingRoom.width + 1 &&
                            newRoom.x + newRoom.width + 1 > existingRoom.x &&
                            newRoom.y < existingRoom.y + existingRoom.height + 1 &&
                            newRoom.y + newRoom.height + 1 > existingRoom.y
                        ) {
                            overlaps = true;
                            break;
                        }
                    }
                    attempts++;
                    if (attempts > maxAttempts) {
                        console.warn("Could not place additional room after many attempts.");
                        break;
                    }
                } while (overlaps && attempts <= maxAttempts);

                if (!overlaps) {
                    rooms.push(newRoom);
                    // Carve out the new room
                    for (let y = newRoom.y; y < newRoom.y + newRoom.height; y++) {
                        for (let x = newRoom.x; x < newRoom.x + newRoom.width; x++) {
                            if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
                                map[y][x] = 'floor';
                            }
                        }
                    }
                }
            }

            // 6. Connect all rooms (including the hub) with corridors
            // Connect each additional room to the hub
            for (let i = 1; i < rooms.length; i++) { // Start from 1 to skip the hub
                const room = rooms[i];
                const targetRoom = hub; // Connect to the hub

                const center1 = { x: Math.floor(room.x + room.width / 2), y: Math.floor(room.y + room.height / 2) };
                const center2 = { x: Math.floor(targetRoom.x + targetRoom.width / 2), y: Math.floor(targetRoom.y + targetRoom.height / 2) };

                // Horizontal corridor
                for (let x = Math.min(center1.x, center2.x); x <= Math.max(center1.x, center2.x); x++) {
                    if (x >= 0 && x < MAP_WIDTH && center1.y >= 0 && center1.y < MAP_HEIGHT) {
                        map[center1.y][x] = 'floor';
                    }
                }

                // Vertical corridor
                for (let y = Math.min(center1.y, center2.y); y <= Math.max(center1.y, center2.y); y++) {
                    if (center2.x >= 0 && center2.x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
                        map[y][center2.x] = 'floor';
                    }
                }
            }
        }
        // --- End Dungeon Generation Logic ---

        /**
         * Spawns enemies randomly on the map.
         * This function is now called only if no enemy data is found in Supabase.
         */
        function spawnEnemies() {
            enemies = [];
            const numEnemies = Math.floor(Math.random() * 5) + 3;
            for (let i = 0; i < numEnemies; i++) {
                let enemyX, enemyY;
                let attempts = 0;
                const maxAttempts = 100;
                do {
                    enemyX = Math.floor(Math.random() * MAP_WIDTH);
                    enemyY = Math.floor(Math.random() * MAP_HEIGHT);
                    attempts++;
                    if (attempts > maxAttempts) {
                        console.warn("Could not find a suitable spot for an enemy after many attempts.");
                        break;
                    }
                } while (
                    map[enemyY][enemyX] === 'wall' || // Avoid walls
                    (enemyX === player.x && enemyY === player.y) || // Avoid player's exact spawn point
                    getEnemyAt(enemyX, enemyY) || // Avoid overlapping other enemies
                    (enemyX >= HUB_X && enemyX < HUB_X + HUB_WIDTH && enemyY >= HUB_Y && enemyY < HUB_Y + HUB_HEIGHT) || // Avoid central hub
                    (enemyX === Math.floor(HUB_X + HUB_WIDTH / 2) && enemyY < HUB_Y) || // Avoid North corridor
                    (enemyY === Math.floor(HUB_Y + HUB_HEIGHT / 2) && enemyX < HUB_X) || // Avoid West corridor
                    (enemyX === Math.floor(HUB_X + HUB_WIDTH / 2) && enemyY >= HUB_Y + HUB_HEIGHT) || // Avoid South corridor
                    (enemyY === Math.floor(HUB_Y + HUB_HEIGHT / 2) && enemyX >= HUB_X + HUB_WIDTH) // Avoid East corridor
                );

                if (attempts <= maxAttempts) {
                    enemies.push({
                        x: enemyX,
                        y: enemyY,
                        health: 30,
                        attack: 8,
                        defense: 2,
                        xpValue: 10,
                        name: 'Гоблин',
                        id: crypto.randomUUID() // Добавить уникальный ID для врагов
                    });
                }
            }
            console.log("Enemies spawned locally:", enemies);
        }

        /**
         * Gets an enemy object at the given coordinates.
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @returns {object|null} Объект врага, если найден, иначе null.
         */
        function getEnemyAt(x, y) {
            return enemies.find(enemy => enemy.x === x && enemy.y === y);
        }

        /**
         * Logs a message to the game message log.
         * @param {string} message - Сообщение для логирования.
         */
        function logMessage(message) {
            const p = document.createElement('p');
            p.textContent = message;
            messageLogEl.prepend(p);
            if (messageLogEl.children.length > 20) {
                messageLogEl.removeChild(messageLogEl.lastChild);
            }
        }

        /**
         * Updates the UI elements with current player stats.
         */
        function updateUI() {
            playerHealthEl.textContent = player.health;
            playerAttackEl.textContent = player.attack;
            playerDefenseEl.textContent = player.defense;
            playerXPEl.textContent = player.xp;
            playerLevelEl.textContent = player.level;
            playerXEl.textContent = player.x;
            playerYEl.textContent = player.y;
            playerChunkXEl.textContent = player.chunkX; // Обновить отображение чанка X
            playerChunkYEl.textContent = player.chunkY; // Обновить отображение чанка Y

            inventoryListEl.innerHTML = '';
            if (player.inventory.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'Пусто';
                inventoryListEl.appendChild(li);
            } else {
                player.inventory.forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = item.name;
                    inventoryListEl.appendChild(li);
                });
            }

            otherPlayersListEl.innerHTML = '';
            // Only show other players if Supabase is connected
            if (!supabase || !userId || otherPlayers.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'Нет других игроков (или Supabase не подключен)';
                otherPlayersListEl.appendChild(li);
            } else {
                otherPlayers.forEach(otherPlayer => {
                    const li = document.createElement('li');
                    li.textContent = `${otherPlayer.name} (Уровень ${otherPlayer.level}) - X:${otherPlayer.x}, Y:${otherPlayer.y}, Чанк: (${otherPlayer.chunkX || 0}, ${otherPlayer.chunkY || 0})`;
                    otherPlayersListEl.appendChild(li);
                });
            }
        }

        /**
         * Draws the game state on the canvas.
         */
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw map tiles
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    if (!map[y] || map[y][x] === undefined) {
                        console.warn(`Map tile at (${x}, ${y}) is undefined. Skipping draw.`);
                        continue;
                    }

                    const tileType = map[y][x];
                    let color = '#333'; // Default floor color
                    if (tileType === 'wall') {
                        if (wallImage.isLoaded) {
                            ctx.drawImage(wallImage, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        } else {
                            color = '#666'; // Fallback wall color
                            ctx.fillStyle = color;
                            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }
                    } else {
                        ctx.fillStyle = color;
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }

                    ctx.strokeStyle = '#222';
                    ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }

            // Draw enemies
            enemies.forEach(enemy => {
                if (goblinImage.isLoaded) {
                    ctx.drawImage(goblinImage, enemy.x * TILE_SIZE, enemy.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                } else {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(enemy.x * TILE_SIZE + TILE_SIZE / 4, enemy.y * TILE_SIZE + TILE_SIZE / 4, TILE_SIZE / 2, TILE_SIZE / 2);
                }
            });

            // Draw players (current and others)
            const allPlayersToDraw = [player, ...otherPlayers];
            allPlayersToDraw.forEach(p => {
                // Только рисовать игроков в текущем чанке
                if (p.chunkX === player.chunkX && p.chunkY === player.chunkY) {
                    let playerColor = 'blue'; // Default for current player
                    if (p.id !== player.id) {
                        playerColor = 'green'; // Default for other players
                    }

                    if (playerImage.isLoaded) {
                        ctx.drawImage(playerImage, p.x * TILE_SIZE, p.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    } else {
                        ctx.fillStyle = playerColor;
                        ctx.fillRect(p.x * TILE_SIZE, p.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                    ctx.fillStyle = 'white';
                    ctx.font = '10px Inter';
                    ctx.fillText(p.name, p.x * TILE_SIZE, p.y * TILE_SIZE - 5);
                }
            });
        }

        /**
         * Updates the current player's data in Supabase.
         */
        async function updatePlayerPositionInSupabase() {
            // Only update Supabase if it's initialized
            if (!supabase || !userId) {
                console.warn("Supabase not available, skipping player position update.");
                return;
            }

            if (!gameReady || !player.id) {
                console.warn("Game not ready or player ID not set for update.");
                return;
            }
            try {
                const { data, error } = await supabase
                    .from('players')
                    .upsert({
                        id: player.id,
                        name: player.name,
                        x: player.x,
                        y: player.y,
                        chunkX: player.chunkX, // Сохранить chunkX
                        chunkY: player.chunkY, // Сохранить chunkY
                        health: player.health,
                        maxhealth: player.maxhealth,
                        attack: player.attack,
                        defense: player.defense,
                        xp: player.xp,
                        level: player.level,
                        updated_at: new Date().toISOString()
                    }, { onConflict: 'id' });

                if (error) {
                    console.error("Ошибка записи данных игрока в Supabase:", error);
                    logMessage("Ошибка сохранения вашего прогресса.");
                } else {
                    // console.log("Player data saved to Supabase:", data);
                }
            }
            catch (e) {
                console.error("Исключение при записи данных игрока в Supabase:", e);
                logMessage("Ошибка сохранения вашего прогресса.");
            }
        }

        /**
         * Updates the global game state (map and enemies) in Supabase.
         */
        async function updateGameStateInSupabase() {
            // Only update Supabase if it's initialized
            if (!supabase || !userId) {
                console.warn("Supabase not available, skipping game state update.");
                return;
            }

            if (!gameReady) {
                console.warn("Game not ready for game state update.");
                return;
            }
            try {
                const { data, error } = await supabase
                    .from('game_state')
                    .upsert({
                        id: getCurrentWorldId(), // Использовать динамический ID
                        map_data: JSON.stringify(map),
                        enemies_data: JSON.stringify(enemies),
                        updated_at: new Date().toISOString()
                    }, { onConflict: 'id' });

                if (error) {
                    console.error("Ошибка записи глобального состояния игры в Supabase:", error);
                    logMessage("Ошибка сохранения состояния мира.");
                } else {
                    console.log(`Global game state for chunk ${getCurrentWorldId()} saved to Supabase.`);
                }
            } catch (e) {
                console.error("Исключение при записи глобального состояния игры в Supabase:", e);
                logMessage("Ошибка сохранения состояния мира.");
            }
        }

        /**
         * Listens for real-time updates of other players from Supabase.
         * Also fetches existing players on initial load.
         */
        async function listenForOtherPlayers() { // Made async
            // Only listen if Supabase is initialized
            if (!supabase || !userId) {
                console.warn("Supabase not available, skipping real-time player listener.");
                return;
            }

            if (!gameReady || !player.id) {
                console.warn("Game not ready, Supabase client not available, or player ID not set for listening to other players.");
                return;
            }

            // Отписаться от предыдущего канала, если существует (для всех игроков)
            if (supabase.channel('players_changes')) {
                supabase.channel('players_changes').unsubscribe();
            }

            // --- NEW: Fetch all existing players on initial load ---
            try {
                const { data, error } = await supabase
                    .from('players')
                    .select('*'); // Select all player data

                if (error) {
                    console.error("Ошибка при получении списка существующих игроков:", error);
                    logMessage("Ошибка загрузки других игроков.");
                } else if (data) {
                    // Filter out the current player and populate otherPlayers
                    otherPlayers = data.filter(p => p.id !== player.id);
                    console.log("Existing other players fetched:", otherPlayers);
                }
            } catch (e) {
                console.error("Исключение при получении списка существующих игроков:", e);
                logMessage("Ошибка загрузки других игроков.");
            }
            // --- END NEW ---

            supabase
                .channel('players_changes')
                .on('postgres_changes', { event: '*', schema: 'public', table: 'players' }, payload => {
                    console.log('Player change received!', payload);
                    console.log('Payload for player change:', payload.new);
                    if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
                        const changedPlayer = payload.new;
                        // If this is our own player, update their data, but not add to otherPlayers
                        if (changedPlayer.id === player.id) {
                            player.x = changedPlayer.x;
                            player.y = changedPlayer.y; 
                            player.chunkX = changedPlayer.chunkX;
                            player.chunkY = changedPlayer.chunkY;
                            player.health = changedPlayer.health;
                            player.maxhealth = changedPlayer.maxhealth;
                            player.attack = changedPlayer.attack;
                            player.defense = changedPlayer.defense;
                            player.xp = changedPlayer.xp;
                            player.level = changedPlayer.level;
                            // Not calling drawGame/updateUI here, as it will be done after movePlayer
                            return;
                        }

                        const existingIndex = otherPlayers.findIndex(p => p.id === changedPlayer.id);
                        if (existingIndex > -1) {
                            otherPlayers[existingIndex] = changedPlayer; // Update existing player
                        } else {
                            otherPlayers.push(changedPlayer); // Add new player
                        }
                    } else if (payload.eventType === 'DELETE') {
                        const deletedPlayerId = payload.old.id;
                        otherPlayers = otherPlayers.filter(p => p.id !== deletedPlayerId); // Remove deleted player
                    }
                    console.log('Current otherPlayers array:', otherPlayers);
                    drawGame();
                    updateUI();
                })
                .subscribe();

            logMessage("Подписка на других игроков активна.");
            // Initial draw and UI update after fetch
            drawGame();
            updateUI();
        }

        /**
         * Listens for real-time updates to the global game state (map and enemies).
         */
        function listenForGameStateChanges() {
            // Only listen if Supabase is initialized
            if (!supabase || !userId) {
                console.warn("Supabase not available, skipping real-time game state listener.");
                return;
            }

            if (!gameReady) {
                console.warn("Game not ready for listening to game state.");
                return;
            }

            // Отписаться от предыдущего канала, если существует
            if (supabase.channel('game_state_changes')) {
                supabase.channel('game_state_changes').unsubscribe();
            }

            supabase
                .channel('game_state_changes')
                .on('postgres_changes', { event: '*', schema: 'public', table: 'game_state', filter: `id=eq.${getCurrentWorldId()}` }, payload => { // Фильтровать по ID текущего чанка
                    console.log('Game state change received!', payload);
                    if (payload.eventType === 'UPDATE') {
                        const updatedState = payload.new;
                        map = JSON.parse(updatedState.map_data);
                        enemies = JSON.parse(updatedState.enemies_data);
                        logMessage("Мир обновлен.");
                        drawGame();
                    }
                })
                .subscribe();

            logMessage(`Подписка на состояние мира ${getCurrentWorldId()} активна.`);
        }


        /**
         * Handles player movement.
         * @param {number} dx - Изменение по X-координате.
         * @param {number} dy - Изменение по Y-координате.
         */
        async function movePlayer(dx, dy) {
            if (!gameReady) return;

            let newX = player.x + dx;
            let newY = player.y + dy;
            let newChunkX = player.chunkX;
            let newChunkY = player.chunkY;
            let transitionOccurred = false;

            // Проверка на переход между чанками мира
            if (newX < 0) {
                newChunkX--;
                newX = MAP_WIDTH - 1;
                transitionOccurred = true;
            } else if (newX >= MAP_WIDTH) {
                newChunkX++;
                newX = 0;
                transitionOccurred = true;
            }

            if (newY < 0) {
                newChunkY--;
                newY = MAP_HEIGHT - 1;
                transitionOccurred = true;
            } else if (newY >= MAP_HEIGHT) {
                newChunkY++;
                newY = 0;
                transitionOccurred = true;
            }

            // Если произошел переход, обновить чанк игрока и загрузить новое состояние
            if (transitionOccurred) {
                player.chunkX = newChunkX;
                player.chunkY = newChunkY;
                player.x = newX;
                player.y = newY;
                logMessage(`Вы перешли в новую локацию: (${player.chunkX}, ${player.chunkY}).`);
                await updatePlayerPositionInSupabase(); // Сохранить новую позицию игрока (включая чанк)
                await loadOrCreateGameState(); // Загрузить карту и врагов нового чанка
                listenForGameStateChanges(); // Переподписаться на состояние нового чанка
                // listenForOtherPlayers() не требует переподписки, так как она слушает все изменения игроков
                drawGame();
                updateUI();
                return; // Перемещение обработано переходом
            }

            // Если перехода нет, продолжить перемещение в текущем чанке
            // Проверка на стены (из общих данных карты)
            if (map[newY][newX] === 'wall') {
                logMessage('Стена блокирует ваш путь.');
                return;
            }

            // Проверка на врагов (из общих данных врагов)
            const targetEnemy = getEnemyAt(newX, newY);
            if (targetEnemy) {
                logMessage(`Вы атакуете ${targetEnemy.name}!`);
                combat(player, targetEnemy);
                return; // Не двигаться при атаке
            }

            // Если препятствий нет, переместить игрока
            player.x = newX;
            player.y = newY;
            logMessage(`Вы переместились на (${player.x}, ${player.y}) в текущей локации.`);

            // Обновить позицию игрока в Supabase
            await updatePlayerPositionInSupabase();

            drawGame();
            updateUI();
        }

        /**
         * Handles combat between attacker and defender.
         * @param {object} attacker - Атакующая сущность (игрок или враг).
         * @param {object} defender - Защищающаяся сущность (игрок или враг).
         */
        async function combat(attacker, defender) {
            let damage = Math.max(0, attacker.attack - defender.defense);
            defender.health -= damage;
            logMessage(`${attacker.name} наносит ${damage} урона ${defender.name}.`);

            if (defender.health <= 0) {
                logMessage(`${defender.name} побежден!`);
                if (defender === player) {
                    logMessage('Вы были побеждены. Игра окончена!');
                    // Реализовать логику окончания игры (например, перезапуск игры, показ сообщения)
                } else {
                    // Враг побежден - обновить глобальное состояние врагов
                    player.xp += defender.xpValue;
                    logMessage(`Вы получили ${defender.xpValue} опыта.`);
                    enemies = enemies.filter(e => e.id !== defender.id); // Фильтровать по ID для корректного удаления
                    await updateGameStateInSupabase(); // Сохранить обновленных врагов
                    checkLevelUp();
                }
            } else {
                // Если защитник все еще жив, он может ответить (если это пошаговая игра)
                if (defender === player) {
                    // Игрок был атакован, ответной атаки в этой простой модели пока нет
                } else {
                    // Враг отвечает
                    logMessage(`${defender.name} отвечает!`);
                    combat(defender, attacker); // Враг атакует игрока в ответ
                }
            }
            drawGame();
            updateUI();
        }

        /**
         * Checks if the player has enough XP to level up.
         */
        function checkLevelUp() {
            const xpNeededForNextLevel = player.level * 50;
            if (player.xp >= xpNeededForNextLevel) {
                player.level++;
                player.xp -= xpNeededForNextLevel;
                player.maxhealth += 10;
                player.health = player.maxhealth;
                player.attack += 2;
                player.defense += 1;
                logMessage(`Поздравляем! Вы достигли уровня ${player.level}!`);
                updateUI();
                updatePlayerPositionInSupabase(); // Обновить статистику в Supabase
            }
        }

        /**
         * Handles keyboard input for player movement.
         * @param {KeyboardEvent} event - Событие клавиатуры.
         */
        function handleKeyDown(event) {
            switch (event.key) {
                case 'w':
                case 'ArrowUp':
                    movePlayer(0, -1);
                    break;
                case 's':
                case 'ArrowDown':
                    movePlayer(0, 1);
                    break;
                case 'a':
                case 'ArrowLeft':
                    movePlayer(-1, 0);
                    break;
                case 'd':
                case 'ArrowRight':
                    movePlayer(1, 0);
                    break;
            }
        }

        /**
         * Recreates the current dungeon chunk.
         */
        async function recreateDungeon() {
            if (!gameReady) {
                console.warn("Game not ready for dungeon recreation.");
                return;
            }
            logMessage('Пересоздание подземелья...');
            initializeMap(); // Сгенерировать новое подземелье для текущего чанка
            spawnEnemies(); // Сгенерировать новых врагов для текущего чанка
            await updateGameStateInSupabase(); // Сохранить новое состояние в Supabase
            drawGame();
            updateUI();
            logMessage('Подзеземелье пересоздано!');
            console.log(`Dungeon for chunk ${getCurrentWorldId()} recreated.`);
        }

        // Main game initialization function
        async function initializeGame() {
            // Get loading overlay element as early as possible
            const loadingOverlay = document.getElementById('loadingOverlay');

            // Show loading overlay initially
            loadingOverlay.style.display = 'flex';
            console.log("Game initialization started. Showing loading overlay.");

            // Immediately initialize local game state and draw
            initializeMap();
            spawnEnemies();
            drawGame(); // Initial draw
            updateUI(); // Initial UI update
            document.addEventListener('keydown', handleKeyDown);
            logMessage('Используйте клавиши WASD или стрелки для перемещения.');

            // Set gameReady to true to allow player movement and local game logic
            gameReady = true;
            player.name = `Локальный Игрок ${player.id.substring(0, 6)}`; // Set local player name
            playerIDEl.textContent = player.id; // Display local ID
            updateUI(); // Update UI to reflect local mode status initially

            // Hide the loading overlay immediately after initial local setup
            console.log("Attempting to hide loading overlay directly via style.display = 'none'...");
            loadingOverlay.style.display = 'none'; // Directly hide the element
            console.log("Loading overlay should now be hidden. Game should be visible locally.");

            // Attempt Supabase connection and full game setup in the background
            try {
                console.log("Attempting Supabase connection for online features...");
                await initializeSupabaseConnection(); // This will set supabase and userId if successful
                
                // If Supabase connection was successful, proceed with online features setup
                console.log("Supabase connection successful. Proceeding with online features setup.");
                await setupOnlineGameFeatures();

            } catch (error) {
                console.error("Фатальная ошибка при инициализации игры или подключении к Supabase:", error);
                logMessage("Критическая ошибка. Игра запускается в одиночном режиме без сохранения.");
                
                // Ensure local mode variables are set correctly on error
                supabase = null;
                userId = null;
                // Player ID and name are already set for local mode by default (crypto.randomUUID)
                playerIDEl.textContent = player.id; // Update UI to show local ID
                
                // Re-draw and update UI to reflect local mode
                initializeMap(); // Re-initialize map in case of partial failure
                spawnEnemies();
                drawGame();
                updateUI();
                document.addEventListener('keydown', handleKeyDown); // Ensure listener is still there
                logMessage("Подключение к Supabase не удалось. Игра работает в одиночном режиме.");

                // Ensure overlay is hidden even on error (should already be hidden, but for robustness)
                loadingOverlay.style.display = 'none';
                console.log("Loading overlay confirmed hidden after error. Game should now be visible locally.");
            }
        }

        window.onload = initializeGame;
    </script>
</body>
</html>
