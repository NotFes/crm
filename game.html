<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Простая RPG</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .game-container {
            position: relative; /* Для позиционирования оверлея */
            display: flex;
            flex-direction: column;
            gap: 20px;
            background-color: #2d3748; /* Slightly lighter dark background */
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 100%;
        }
        canvas {
            background-color: #000;
            border: 2px solid #4a5568;
            border-radius: 8px;
            display: block;
            width: 100%; /* Make canvas responsive */
            max-width: 600px; /* Max width for canvas */
            aspect-ratio: 1 / 1; /* Keep it square */
            margin: 0 auto;
        }
        .game-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background-color: #2d3748;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #4a5568;
        }
        .game-info h2 {
            font-size: 1.25rem;
            font-weight: bold;
            color: #a0aec0;
            margin-bottom: 5px;
        }
        .game-info p {
            font-size: 1rem;
            color: #cbd5e0;
        }
        .message-log {
            background-color: #1a202c;
            border: 1px solid #4a5568;
            border-radius: 8px;
            padding: 10px;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.9rem;
            color: #a0aec0;
        }
        .message-log p {
            margin: 0;
            padding: 2px 0;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .control-button {
            background-color: #4299e1; /* Blue */
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .control-button:hover {
            background-color: #3182ce; /* Darker blue */
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            .game-container {
                flex-direction: row;
                justify-content: space-between;
                align-items: flex-start;
            }
            .game-main {
                flex: 2;
                display: flex;
                flex-direction: column;
                gap: 20px;
            }
            .game-sidebar {
                flex: 1;
                min-width: 250px;
                display: flex;
                flex-direction: column;
                gap: 20px;
            }
        }

        /* Loading overlay styles */
        #loadingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            z-index: 100;
            border-radius: 12px; /* Match container border-radius */
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="loadingOverlay">Загрузка...</div>
        <div class="message-log" id="messageLog">
            <p>Добро пожаловать в подземелье!</p>
        </div>
        <div class="controls">
            <button class="control-button" onclick="movePlayer(0, -1)">Вверх</button>
            <button class="control-button" onclick="movePlayer(0, 1)">Вниз</button>
            <button class="control-button" onclick="movePlayer(-1, 0)">Влево</button>
            <button class="control-button" onclick="movePlayer(1, 0)">Вправо</button>
        </div>
        <div class="game-sidebar">
            <div class="game-info">
                <h2>Игрок</h2>
                <p>ID: <span id="playerID"></span></p>
                <p>Здоровье: <span id="playerHealth">100</span></p>
                <p>Атака: <span id="playerAttack">10</span></p>
                <p>Защита: <span id="playerDefense">5</span></p>
                <p>Опыт: <span id="playerXP">0</span></p>
                <p>Уровень: <span id="playerLevel">1</span></p>
            </div>
            <div class="game-info">
                <h2>Инвентарь</h2>
                <ul id="inventoryList" class="list-disc list-inside">
                    <li>Пусто</li>
                </ul>
            </div>
            <div class="game-info">
                <h2>Текущая локация</h2>
                <p>X: <span id="playerX">0</span>, Y: <span id="playerY">0</span></p>
            </div>
            <div class="game-info">
                <h2>Другие игроки</h2>
                <ul id="otherPlayersList" class="list-disc list-inside">
                    <li>Нет других игроков</li>
                </ul>
            </div>
        </div>
    </div>

    <script type="module">
        // Supabase imports
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

        // Supabase configuration
        const SUPABASE_URL = 'https://kbjlqmzeclrtowtygbvu.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtiamxxbXplY2xydG93dHlnYnZ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc4NTU2ODksImV4cCI6MjA2MzQzMTY4OX0.17nwxPRZnSMzwSbtAo83bxFEFWP5rdhjhUNuxxLLGP8';
        const WORLD_ID = 'world_1'; // Идентификатор для глобального состояния мира

        let supabase;
        let userId;
        let gameReady = false;

        // Game configuration
        const TILE_SIZE = 40;
        const MAP_WIDTH = 15;
        const MAP_HEIGHT = 15;

        // Game state
        let player = {
            id: '',
            name: 'Игрок',
            x: 0,
            y: 0,
            health: 100,
            maxhealth: 100,
            attack: 10,
            defense: 5,
            xp: 0,
            level: 1,
            inventory: []
        };

        let map = []; // 2D array to represent the game map (shared)
        let enemies = []; // Array to store enemy objects (shared)
        let otherPlayers = [];

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const loadingOverlay = document.getElementById('loadingOverlay');

        canvas.width = MAP_WIDTH * TILE_SIZE;
        canvas.height = MAP_HEIGHT * TILE_SIZE;

        // Player image
        const playerImage = new Image();
        playerImage.src = 'https://www.speedrun.com/static/user/j5wngezj/icon.png';
        playerImage.isLoaded = false;
        playerImage.onload = () => {
            console.log("Player image loaded successfully!");
            playerImage.isLoaded = true;
        };
        playerImage.onerror = () => {
            console.error("Failed to load player image.");
            playerImage.isLoaded = false;
        };

        // UI elements
        const playerIDEl = document.getElementById('playerID');
        const playerHealthEl = document.getElementById('playerHealth');
        const playerAttackEl = document.getElementById('playerAttack');
        const playerDefenseEl = document.getElementById('playerDefense');
        const playerXPEl = document.getElementById('playerXP');
        const playerLevelEl = document.getElementById('playerLevel');
        const playerXEl = document.getElementById('playerX');
        const playerYEl = document.getElementById('playerY');
        const inventoryListEl = document.getElementById('inventoryList');
        const messageLogEl = document.getElementById('messageLog');
        const otherPlayersListEl = document.getElementById('otherPlayersList');

        /**
         * Initializes Supabase and authenticates the user (anonymously).
         */
        async function initializeSupabase() {
            loadingOverlay.style.display = 'flex'; // Show loading overlay
            try {
                supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log("Supabase client initialized.");
                console.log("URL:", SUPABASE_URL);
                console.log("Anon Key (first 10 chars):", SUPABASE_ANON_KEY.substring(0, 10) + "...");

                const authPromise = new Promise(async (resolve, reject) => {
                    // This listener will catch both initial session and new sign-ins
                    supabase.auth.onAuthStateChange((event, session) => {
                        console.log("Auth state change event:", event);
                        if (session && session.user) {
                            resolve(session.user);
                        } else if (event === 'SIGNED_OUT') {
                            // If signed out, we might want to reject or handle differently
                            // For this game, we'll try to sign in anonymously again if needed.
                            console.log("User signed out, attempting anonymous sign-in if no session.");
                        }
                    });

                    // First, try to get the current session
                    const { data: { session }, error: getSessionError } = await supabase.auth.getSession();

                    if (getSessionError) {
                        console.error("Ошибка получения сессии:", getSessionError);
                        logMessage("Ошибка получения сессии. Попытка анонимного входа...");
                        const { error: signInError } = await supabase.auth.signInAnonymously();
                        if (signInError) {
                            console.error("Критическая ошибка анонимного входа:", signInError);
                            logMessage("Ошибка входа в игру. Пожалуйста, проверьте URL и ключ Supabase, а также настройки RLS.");
                            reject(signInError); // Reject if anonymous sign-in also fails
                        } else {
                            console.log("Анонимный вход успешно инициирован.");
                            // onAuthStateChange will handle the resolution
                        }
                    } else if (!session) {
                        // No existing session, try to sign in anonymously
                        console.log("Нет активной сессии. Попытка анонимного входа...");
                        const { error: signInError } = await supabase.auth.signInAnonymously();
                        if (signInError) {
                            console.error("Критическая ошибка анонимного входа:", signInError);
                            logMessage("Ошибка входа в игру. Пожалуйста, проверьте URL и ключ Supabase, а также настройки RLS.");
                            reject(signInError); // Reject if anonymous sign-in fails
                        } else {
                            console.log("Анонимный вход успешно инициирован.");
                            // onAuthStateChange will handle the resolution
                        }
                    } else {
                        // Session exists, resolve immediately with user data
                        console.log("Существует активная сессия, пользователь:", session.user.id);
                        resolve(session.user);
                    }
                });

                const user = await authPromise;
                userId = user.id;
                player.id = userId;
                player.name = `Игрок ${userId.substring(0, 6)}`;
                playerIDEl.textContent = userId;
                logMessage(`Вы вошли как: ${player.name}`);
                gameReady = true;
                console.log("Calling setupGame...");
                await setupGame(); // Now setupGame is guaranteed to run after authentication

            } catch (error) {
                console.error("Критическая ошибка инициализации Supabase:", error);
                logMessage("Критическая ошибка подключения к игре. Пожалуйста, попробуйте позже.");
            } finally {
                loadingOverlay.style.display = 'none'; // Hide loading overlay
            }
        }

        /**
         * Sets up the game state and listeners after Supabase is ready.
         */
        async function setupGame() {
            // 1. Load or initialize global game state (map and enemies)
            await loadOrCreateGameState();

            // 2. Load or initialize player data
            const { data: existingPlayer, error: fetchPlayerError } = await supabase
                .from('players')
                .select('*')
                .eq('id', player.id)
                .single();

            if (fetchPlayerError && fetchPlayerError.code !== 'PGRST116') {
                console.error("Ошибка загрузки данных игрока:", fetchPlayerError);
                logMessage("Ошибка загрузки вашего прогресса.");
            } else if (existingPlayer) {
                player.x = existingPlayer.x;
                player.y = existingPlayer.y;
                player.health = existingPlayer.health;
                player.maxhealth = existingPlayer.maxhealth;
                player.attack = existingPlayer.attack;
                player.defense = existingPlayer.defense;
                player.xp = existingPlayer.xp;
                player.level = existingPlayer.level;
                logMessage("Ваш прогресс загружен.");
            } else {
                await updatePlayerPositionInSupabase(); // Insert initial player state
                logMessage("Новый профиль игрока создан.");
            }

            // 3. Set up real-time listeners
            listenForOtherPlayers();
            listenForGameStateChanges(); // Listen for changes to map/enemies

            // 4. Initial draw and UI update
            drawGame();
            updateUI();
            document.addEventListener('keydown', handleKeyDown);
            logMessage('Используйте клавиши WASD или стрелки для перемещения.');
        }

        /**
         * Loads global game state (map and enemies) from Supabase, or creates it if not found.
         */
        async function loadOrCreateGameState() {
            console.log("Attempting to load game state...");
            const { data, error } = await supabase
                .from('game_state')
                .select('*')
                .eq('id', WORLD_ID)
                .single();

            if (error && error.code !== 'PGRST116') { // PGRST116 means "no rows found"
                console.error("Ошибка загрузки глобального состояния игры:", error);
                logMessage("Ошибка загрузки мира.");
                // Fallback: initialize locally if loading fails
                initializeMap();
                spawnEnemies();
                await updateGameStateInSupabase(); // Try to save the newly generated state
            } else if (data) {
                console.log("Global game state loaded:", data);
                // Parse and load map and enemies
                map = JSON.parse(data.map_data);
                enemies = JSON.parse(data.enemies_data);
                logMessage("Мир загружен.");
            } else {
                console.log("No existing game state found. Initializing new world...");
                // No existing state, create a new one
                initializeMap();
                spawnEnemies();
                await updateGameStateInSupabase(); // Save the newly generated state
                logMessage("Новый мир создан.");
            }
        }

        /**
         * Initializes the game map with walls and empty spaces.
         * This function is now called only if no map data is found in Supabase.
         */
        function initializeMap() {
            map = []; // Ensure map is empty before filling
            for (let y = 0; y < MAP_HEIGHT; y++) {
                map[y] = [];
                for (let x = 0; x < MAP_WIDTH; x++) {
                    map[y][x] = 'floor';
                }
            }

            for (let i = 0; i < (MAP_WIDTH * MAP_HEIGHT) / 10; i++) {
                const wallX = Math.floor(Math.random() * MAP_WIDTH);
                const wallY = Math.floor(Math.random() * MAP_HEIGHT);
                if (map[wallY] && map[wallY][wallX] !== undefined && (wallX !== player.x || wallY !== player.y)) {
                    map[wallY][wallX] = 'wall';
                }
            }
            console.log("Map initialized locally:", map);
        }

        /**
         * Spawns enemies randomly on the map.
         * This function is now called only if no enemy data is found in Supabase.
         */
        function spawnEnemies() {
            enemies = [];
            const numEnemies = Math.floor(Math.random() * 5) + 3;
            for (let i = 0; i < numEnemies; i++) {
                let enemyX, enemyY;
                let attempts = 0;
                const maxAttempts = 100;
                do {
                    enemyX = Math.floor(Math.random() * MAP_WIDTH);
                    enemyY = Math.floor(Math.random() * MAP_HEIGHT);
                    attempts++;
                    if (attempts > maxAttempts) {
                        console.warn("Could not find a suitable spot for an enemy after many attempts.");
                        break;
                    }
                } while (map[enemyY][enemyX] === 'wall' || (enemyX === player.x && enemyY === player.y) || getEnemyAt(enemyX, enemyY));

                if (attempts <= maxAttempts) {
                    enemies.push({
                        x: enemyX,
                        y: enemyY,
                        health: 30,
                        attack: 8,
                        defense: 2,
                        xpValue: 10,
                        name: 'Гоблин'
                    });
                    // Note: We don't update map[enemyY][enemyX] = 'enemy' here.
                    // The map_data in Supabase will only store 'floor'/'wall'.
                    // Enemy positions are tracked separately in enemies_data.
                }
            }
            console.log("Enemies spawned locally:", enemies);
        }

        /**
         * Gets an enemy object at the given coordinates.
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @returns {object|null} The enemy object if found, otherwise null.
         */
        function getEnemyAt(x, y) {
            return enemies.find(enemy => enemy.x === x && enemy.y === y);
        }

        /**
         * Logs a message to the game message log.
         * @param {string} message - The message to log.
         */
        function logMessage(message) {
            const p = document.createElement('p');
            p.textContent = message;
            messageLogEl.prepend(p);
            if (messageLogEl.children.length > 20) {
                messageLogEl.removeChild(messageLogEl.lastChild);
            }
        }

        /**
         * Updates the UI elements with current player stats.
         */
        function updateUI() {
            playerHealthEl.textContent = player.health;
            playerAttackEl.textContent = player.attack;
            playerDefenseEl.textContent = player.defense;
            playerXPEl.textContent = player.xp;
            playerLevelEl.textContent = player.level;
            playerXEl.textContent = player.x;
            playerYEl.textContent = player.y;

            inventoryListEl.innerHTML = '';
            if (player.inventory.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'Пусто';
                inventoryListEl.appendChild(li);
            } else {
                player.inventory.forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = item.name;
                    inventoryListEl.appendChild(li);
                });
            }

            otherPlayersListEl.innerHTML = '';
            if (otherPlayers.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'Нет других игроков';
                otherPlayersListEl.appendChild(li);
            } else {
                otherPlayers.forEach(otherPlayer => {
                    const li = document.createElement('li');
                    li.textContent = `${otherPlayer.name} (Уровень ${otherPlayer.level}) - X:${otherPlayer.x}, Y:${otherPlayer.y}`;
                    otherPlayersListEl.appendChild(li);
                });
            }
        }

        /**
         * Draws the game state on the canvas.
         */
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw map tiles
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    if (!map[y] || map[y][x] === undefined) {
                        console.warn(`Map tile at (${x}, ${y}) is undefined. Skipping draw.`);
                        continue;
                    }

                    const tileType = map[y][x];
                    let color = '#333';
                    if (tileType === 'wall') {
                        color = '#666';
                    }
                    ctx.fillStyle = color;
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                    ctx.strokeStyle = '#222';
                    ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }

            // Draw enemies
            enemies.forEach(enemy => {
                ctx.fillStyle = 'red';
                ctx.fillRect(enemy.x * TILE_SIZE + TILE_SIZE / 4, enemy.y * TILE_SIZE + TILE_SIZE / 4, TILE_SIZE / 2, TILE_SIZE / 2);
            });

            // Draw other players
            otherPlayers.forEach(otherPlayer => {
                if (otherPlayer.id === player.id) return;

                ctx.fillStyle = 'green';
                ctx.fillRect(otherPlayer.x * TILE_SIZE, otherPlayer.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                ctx.fillStyle = 'white';
                ctx.font = '10px Inter';
                ctx.fillText(otherPlayer.name, otherPlayer.x * TILE_SIZE, otherPlayer.y * TILE_SIZE - 5);
            });

            // Draw current player
            if (playerImage.isLoaded) {
                ctx.drawImage(playerImage, player.x * TILE_SIZE, player.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            } else {
                ctx.fillStyle = 'blue';
                ctx.fillRect(player.x * TILE_SIZE, player.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
            ctx.fillStyle = 'white';
            ctx.font = '10px Inter';
            ctx.fillText(player.name, player.x * TILE_SIZE, player.y * TILE_SIZE - 5);
        }

        /**
         * Updates the current player's data in Supabase.
         */
        async function updatePlayerPositionInSupabase() {
            if (!gameReady || !supabase || !player.id) {
                console.warn("Game not ready, Supabase client not available, or player ID not set for update.");
                return;
            }
            try {
                const { data, error } = await supabase
                    .from('players')
                    .upsert({
                        id: player.id,
                        name: player.name,
                        x: player.x,
                        y: player.y,
                        health: player.health,
                        maxhealth: player.maxhealth,
                        attack: player.attack,
                        defense: player.defense,
                        xp: player.xp,
                        level: player.level,
                        updated_at: new Date().toISOString()
                    }, { onConflict: 'id' });

                if (error) {
                    console.error("Ошибка записи данных игрока в Supabase:", error);
                    logMessage("Ошибка сохранения вашего прогресса.");
                } else {
                    // console.log("Player data saved to Supabase:", data);
                }
            } catch (e) {
                console.error("Исключение при записи данных игрока в Supabase:", e);
                logMessage("Ошибка сохранения вашего прогресса.");
            }
        }

        /**
         * Updates the global game state (map and enemies) in Supabase.
         */
        async function updateGameStateInSupabase() {
            if (!gameReady || !supabase) {
                console.warn("Game not ready or Supabase client not available for game state update.");
                return;
            }
            try {
                const { data, error } = await supabase
                    .from('game_state')
                    .upsert({
                        id: WORLD_ID,
                        map_data: JSON.stringify(map),
                        enemies_data: JSON.stringify(enemies),
                        updated_at: new Date().toISOString()
                    }, { onConflict: 'id' });

                if (error) {
                    console.error("Ошибка записи глобального состояния игры в Supabase:", error);
                    logMessage("Ошибка сохранения состояния мира.");
                } else {
                    console.log("Global game state saved to Supabase.");
                }
            } catch (e) {
                console.error("Исключение при записи глобального состояния игры в Supabase:", e);
                logMessage("Ошибка сохранения состояния мира.");
            }
        }

        /**
         * Listens for real-time updates of other players from Supabase.
         */
        function listenForOtherPlayers() {
            if (!gameReady || !supabase || !player.id) {
                console.warn("Game not ready, Supabase client not available, or player ID not set for listening to other players.");
                return;
            }

            supabase
                .channel('players_changes')
                .on('postgres_changes', { event: '*', schema: 'public', table: 'players' }, payload => {
                    console.log('Player change received!', payload);
                    if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
                        const changedPlayer = payload.new;
                        if (changedPlayer.id === player.id) {
                            return;
                        }
                        const existingIndex = otherPlayers.findIndex(p => p.id === changedPlayer.id);
                        if (existingIndex > -1) {
                            otherPlayers[existingIndex] = changedPlayer;
                        } else {
                            otherPlayers.push(changedPlayer);
                        }
                    } else if (payload.eventType === 'DELETE') {
                        const deletedPlayerId = payload.old.id;
                        otherPlayers = otherPlayers.filter(p => p.id !== deletedPlayerId);
                    }
                    drawGame();
                    updateUI();
                })
                .subscribe();

            logMessage("Подписка на других игроков активна.");
        }

        /**
         * Listens for real-time updates to the global game state (map and enemies).
         */
        function listenForGameStateChanges() {
            if (!gameReady || !supabase) {
                console.warn("Game not ready or Supabase client not available for listening to game state.");
                return;
            }

            supabase
                .channel('game_state_changes')
                .on('postgres_changes', { event: '*', schema: 'public', table: 'game_state', filter: `id=eq.${WORLD_ID}` }, payload => {
                    console.log('Game state change received!', payload);
                    if (payload.eventType === 'UPDATE') {
                        const updatedState = payload.new;
                        map = JSON.parse(updatedState.map_data);
                        enemies = JSON.parse(updatedState.enemies_data);
                        logMessage("Мир обновлен.");
                        drawGame();
                    }
                })
                .subscribe();

            logMessage("Подписка на состояние мира активна.");
        }


        /**
         * Handles player movement.
         * @param {number} dx - Change in X coordinate.
         * @param {number} dy - Change in Y coordinate.
         */
        async function movePlayer(dx, dy) {
            if (!gameReady) return;

            const newX = player.x + dx;
            const newY = player.y + dy;

            // Check bounds
            if (newX < 0 || newX >= MAP_WIDTH || newY < 0 || newY >= MAP_HEIGHT) {
                logMessage('Вы не можете идти в этом направлении.');
                return;
            }

            // Check for walls (from shared map data)
            if (map[newY][newX] === 'wall') {
                logMessage('Стена блокирует ваш путь.');
                return;
            }

            // Check for enemies (from shared enemies data)
            const targetEnemy = getEnemyAt(newX, newY);
            if (targetEnemy) {
                logMessage(`Вы атакуете ${targetEnemy.name}!`);
                combat(player, targetEnemy);
                return; // Don't move if attacking
            }

            // If no obstacles, move the player
            player.x = newX;
            player.y = newY;
            logMessage(`Вы переместились на (${player.x}, ${player.y}).`);

            // Update player position in Supabase
            await updatePlayerPositionInSupabase();

            drawGame();
            updateUI();
        }

        /**
         * Handles combat between attacker and defender.
         * @param {object} attacker - The attacking entity (player or enemy).
         * @param {object} defender - The defending entity (player or enemy).
         */
        async function combat(attacker, defender) {
            let damage = Math.max(0, attacker.attack - defender.defense);
            defender.health -= damage;
            logMessage(`${attacker.name} наносит ${damage} урона ${defender.name}.`);

            if (defender.health <= 0) {
                logMessage(`${defender.name} побежден!`);
                if (defender === player) {
                    logMessage('Вы были побеждены. Игра окончена!');
                    // Implement game over logic (e.g., reset game, show message)
                } else {
                    // Enemy defeated - update global enemies state
                    player.xp += defender.xpValue;
                    logMessage(`Вы получили ${defender.xpValue} опыта.`);
                    enemies = enemies.filter(e => e !== defender); // Remove defeated enemy
                    await updateGameStateInSupabase(); // Save updated enemies
                    checkLevelUp();
                }
            } else {
                // If defender is still alive, they might retaliate (if it's turn-based)
                if (defender === player) {
                    // Player was attacked, no retaliation in this simple model yet
                } else {
                    // Enemy retaliates
                    logMessage(`${defender.name} отвечает!`);
                    combat(defender, attacker); // Enemy attacks player back
                }
            }
            drawGame();
            updateUI();
        }

        /**
         * Checks if the player has enough XP to level up.
         */
        function checkLevelUp() {
            const xpNeededForNextLevel = player.level * 50;
            if (player.xp >= xpNeededForNextLevel) {
                player.level++;
                player.xp -= xpNeededForNextLevel;
                player.maxhealth += 10;
                player.health = player.maxhealth;
                player.attack += 2;
                player.defense += 1;
                logMessage(`Поздравляем! Вы достигли уровня ${player.level}!`);
                updateUI();
                updatePlayerPositionInSupabase(); // Update stats in Supabase
            }
        }

        /**
         * Handles keyboard input for player movement.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleKeyDown(event) {
            switch (event.key) {
                case 'w':
                case 'ArrowUp':
                    movePlayer(0, -1);
                    break;
                case 's':
                case 'ArrowDown':
                    movePlayer(0, 1);
                    break;
                case 'a':
                case 'ArrowLeft':
                    movePlayer(-1, 0);
                    break;
                case 'd':
                case 'ArrowRight':
                    movePlayer(1, 0);
                    break;
            }
        }

        // Initialize Supabase and start game on window load
        window.onload = initializeSupabase;
    </script>
</body>
</html>
