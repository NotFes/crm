<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Простая RPG</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            background-color: #2d3748; /* Slightly lighter dark background */
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 100%;
        }
        canvas {
            background-color: #000;
            border: 2px solid #4a5568;
            border-radius: 8px;
            display: block;
            width: 100%; /* Make canvas responsive */
            max-width: 600px; /* Max width for canvas */
            aspect-ratio: 1 / 1; /* Keep it square */
            margin: 0 auto;
        }
        .game-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background-color: #2d3748;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #4a5568;
        }
        .game-info h2 {
            font-size: 1.25rem;
            font-weight: bold;
            color: #a0aec0;
            margin-bottom: 5px;
        }
        .game-info p {
            font-size: 1rem;
            color: #cbd5e0;
        }
        .message-log {
            background-color: #1a202c;
            border: 1px solid #4a5568;
            border-radius: 8px;
            padding: 10px;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.9rem;
            color: #a0aec0;
        }
        .message-log p {
            margin: 0;
            padding: 2px 0;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .control-button {
            background-color: #4299e1; /* Blue */
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .control-button:hover {
            background-color: #3182ce; /* Darker blue */
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            .game-container {
                flex-direction: row;
                justify-content: space-between;
                align-items: flex-start;
            }
            .game-main {
                flex: 2;
                display: flex;
                flex-direction: column;
                gap: 20px;
            }
            .game-sidebar {
                flex: 1;
                min-width: 250px;
                display: flex;
                flex-direction: column;
                gap: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-main">
            <canvas id="gameCanvas"></canvas>
            <div class="message-log" id="messageLog">
                <p>Добро пожаловать в подземелье!</p>
            </div>
            <div class="controls">
                <button class="control-button" onclick="movePlayer(0, -1)">Вверх</button>
                <button class="control-button" onclick="movePlayer(0, 1)">Вниз</button>
                <button class="control-button" onclick="movePlayer(-1, 0)">Влево</button>
                <button class="control-button" onclick="movePlayer(1, 0)">Вправо</button>
            </div>
        </div>
        <div class="game-sidebar">
            <div class="game-info">
                <h2>Игрок</h2>
                <p>ID: <span id="playerID"></span></p>
                <p>Здоровье: <span id="playerHealth">100</span></p>
                <p>Атака: <span id="playerAttack">10</span></p>
                <p>Защита: <span id="playerDefense">5</span></p>
                <p>Опыт: <span id="playerXP">0</span></p>
                <p>Уровень: <span id="playerLevel">1</span></p>
            </div>
            <div class="game-info">
                <h2>Инвентарь</h2>
                <ul id="inventoryList" class="list-disc list-inside">
                    <li>Пусто</li>
                </ul>
            </div>
            <div class="game-info">
                <h2>Текущая локация</h2>
                <p>X: <span id="playerX">0</span>, Y: <span id="playerY">0</span></p>
            </div>
            <div class="game-info">
                <h2>Другие игроки</h2>
                <ul id="otherPlayersList" class="list-disc list-inside">
                    <li>Нет других игроков</li>
                </ul>
            </div>
        </div>
    </div>

    <script type="module">
        // Supabase imports
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

        // Supabase configuration (from your provided details)
        const SUPABASE_URL = 'https://kbjlqmzeclrtowtygbvu.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtiamxxbXplY2xydG93dHlnYnZ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc4NTU2ODksImV4cCI6MjA2MzQzMTY4OX0.17nwxPRZnSMzwSbtAo83bxFEFWP5rdhjhUNuxxLLGP8';

        let supabase;
        let userId; // This will now store the Supabase auth.uid()
        let gameReady = false; // Flag to ensure Supabase is initialized and user ID is set

        // Game configuration
        const TILE_SIZE = 40; // Size of each tile in pixels
        const MAP_WIDTH = 15; // Map width in tiles
        const MAP_HEIGHT = 15; // Map height in tiles

        // Game state
        let player = {
            id: '', // Will be set to Supabase auth.uid()
            name: 'Игрок',
            x: 0,
            y: 0,
            health: 100,
            maxhealth: 100, // <--- ИЗМЕНЕНО: maxHealth -> maxhealth
            attack: 10,
            defense: 5,
            xp: 0,
            level: 1,
            inventory: []
        };

        let map = []; // 2D array to represent the game map
        let enemies = []; // Array to store enemy objects (local to each player for now)
        let otherPlayers = []; // Array to store other connected players

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas dimensions based on map size and tile size
        canvas.width = MAP_WIDTH * TILE_SIZE;
        canvas.height = MAP_HEIGHT * TILE_SIZE;

        // Player image
        const playerImage = new Image();
        playerImage.src = 'https://www.speedrun.com/static/user/j5wngezj/icon.png';
        playerImage.onload = () => {
            console.log("Player image loaded successfully!");
            playerImage.isLoaded = true; // Mark as loaded
            // No direct drawGame() here, it will be called by setupGame()
        };
        playerImage.onerror = () => {
            console.error("Failed to load player image.");
            playerImage.isLoaded = false; // Mark as failed
        };
        playerImage.isLoaded = false; // Initial state

        // UI elements
        const playerIDEl = document.getElementById('playerID');
        const playerHealthEl = document.getElementById('playerHealth');
        const playerAttackEl = document.getElementById('playerAttack');
        const playerDefenseEl = document.getElementById('playerDefense');
        const playerXPEl = document.getElementById('playerXP');
        const playerLevelEl = document.getElementById('playerLevel');
        const playerXEl = document.getElementById('playerX');
        const playerYEl = document.getElementById('playerY');
        const inventoryListEl = document.getElementById('inventoryList');
        const messageLogEl = document.getElementById('messageLog');
        const otherPlayersListEl = document.getElementById('otherPlayersList'); // <--- ИЗМЕНЕНО: Исправлено присваивание

        /**
         * Initializes Supabase and authenticates the user (anonymously).
         */
        async function initializeSupabase() {
            try {
                supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log("Supabase client initialized.");
                console.log("URL:", SUPABASE_URL);
                console.log("Anon Key (first 10 chars):", SUPABASE_ANON_KEY.substring(0, 10) + "...");

                // This listener will handle setting userId and calling setupGame
                // once authentication is successful, whether from a new sign-in
                // or an existing session.
                supabase.auth.onAuthStateChange(async (event, session) => {
                    console.log("Auth state change event:", event);
                    if (session && session.user) {
                        userId = session.user.id;
                        player.id = userId;
                        player.name = `Игрок ${userId.substring(0, 6)}`;
                        playerIDEl.textContent = userId;

                        logMessage(`Вы вошли как: ${player.name}`);
                        if (!gameReady) { // Only call setupGame once
                            gameReady = true;
                            await setupGame();
                        }
                    } else if (event === 'SIGNED_OUT') {
                        logMessage('Вы вышли из системы.');
                        gameReady = false;
                        userId = null;
                        // Optionally handle game state reset or re-login UI
                    }
                });

                // Attempt to get the current session or sign in anonymously
                const { data: { session }, error: getSessionError } = await supabase.auth.getSession();
                if (getSessionError) {
                    console.error("Ошибка получения сессии:", getSessionError);
                    logMessage("Ошибка получения сессии. Попытка анонимного входа...");
                    const { error: signInError } = await supabase.auth.signInAnonymously();
                    if (signInError) {
                        console.error("Ошибка анонимного входа:", signInError);
                        logMessage("Ошибка входа в игру. Пожалуйста, проверьте URL и ключ Supabase, а также настройки RLS.");
                    }
                } else if (!session) {
                    // No existing session, try to sign in anonymously
                    console.log("Нет активной сессии. Попытка анонимного входа...");
                    const { error: signInError } = await supabase.auth.signInAnonymously();
                    if (signInError) {
                        console.error("Ошибка анонимного входа:", signInError);
                        logMessage("Ошибка входа в игру. Пожалуйста, проверьте URL и ключ Supabase, а также настройки RLS.");
                    }
                } else {
                    // Session exists, onAuthStateChange will handle it.
                    console.log("Существует активная сессия.");
                }

            } catch (error) {
                console.error("Критическая ошибка инициализации Supabase:", error);
                logMessage("Критическая ошибка подключения к игре. Пожалуйста, попробуйте позже.");
            }
        }

        /**
         * Sets up the game state and listeners after Supabase is ready.
         */
        async function setupGame() {
            initializeMap();
            spawnEnemies(); // Enemies are local for now

            // Fetch existing player data if it exists, otherwise insert new
            const { data: existingPlayer, error: fetchError } = await supabase
                .from('players')
                .select('*')
                .eq('id', player.id)
                .single();

            if (fetchError && fetchError.code !== 'PGRST116') { // PGRST116 means "no rows found"
                console.error("Ошибка загрузки данных игрока:", fetchError);
                logMessage("Ошибка загрузки вашего прогресса.");
            } else if (existingPlayer) {
                // Load existing player data
                player.x = existingPlayer.x;
                player.y = existingPlayer.y;
                player.health = existingPlayer.health;
                player.maxhealth = existingPlayer.maxhealth; // <--- ИЗМЕНЕНО: maxHealth -> maxhealth
                player.attack = existingPlayer.attack;
                player.defense = existingPlayer.defense;
                player.xp = existingPlayer.xp;
                player.level = existingPlayer.level;
                logMessage("Ваш прогресс загружен.");
            } else {
                // Insert new player data if not found
                await updatePlayerPositionInSupabase(); // This will insert the initial player state
                logMessage("Новый профиль игрока создан.");
            }

            listenForOtherPlayers();
            drawGame();
            updateUI();
            document.addEventListener('keydown', handleKeyDown);
            logMessage('Используйте клавиши WASD или стрелки для перемещения.');
        }

        /**
         * Initializes the game map with walls and empty spaces.
         */
        function initializeMap() {
            // Create a map filled with empty spaces
            for (let y = 0; y < MAP_HEIGHT; y++) {
                map[y] = [];
                for (let x = 0; x < MAP_WIDTH; x++) {
                    map[y][x] = 'floor'; // 'floor', 'wall', 'enemy', 'item'
                }
            }

            // Add some random walls
            for (let i = 0; i < (MAP_WIDTH * MAP_HEIGHT) / 10; i++) {
                const wallX = Math.floor(Math.random() * MAP_WIDTH);
                const wallY = Math.floor(Math.random() * MAP_HEIGHT);
                if (wallX !== player.x || wallY !== player.y) { // Don't place wall on player start
                    map[wallY][wallX] = 'wall';
                }
            }
        }

        /**
         * Spawns enemies randomly on the map.
         */
        function spawnEnemies() {
            enemies = []; // Clear existing enemies
            const numEnemies = Math.floor(Math.random() * 5) + 3; // 3-7 enemies
            for (let i = 0; i < numEnemies; i++) {
                let enemyX, enemyY;
                do {
                    enemyX = Math.floor(Math.random() * MAP_WIDTH);
                    enemyY = Math.floor(Math.random() * MAP_HEIGHT);
                } while (map[enemyY][enemyX] === 'wall' || (enemyX === player.x && enemyY === player.y) || getEnemyAt(enemyX, enemyY));

                enemies.push({
                    x: enemyX,
                    y: enemyY,
                    health: 30,
                    attack: 8,
                    defense: 2,
                    xpValue: 10,
                    name: 'Гоблин' // Placeholder enemy name
                });
                map[enemyY][enemyX] = 'enemy'; // Mark tile as containing an enemy
            }
        }

        /**
         * Gets an enemy object at the given coordinates.
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @returns {object|null} The enemy object if found, otherwise null.
         */
        function getEnemyAt(x, y) {
            return enemies.find(enemy => enemy.x === x && enemy.y === y);
        }

        /**
         * Logs a message to the game message log.
         * @param {string} message - The message to log.
         */
        function logMessage(message) {
            const p = document.createElement('p');
            p.textContent = message;
            messageLogEl.prepend(p); // Add to the top
            if (messageLogEl.children.length > 20) { // Keep log from getting too long
                messageLogEl.removeChild(messageLogEl.lastChild);
            }
        }

        /**
         * Updates the UI elements with current player stats.
         */
        function updateUI() {
            playerHealthEl.textContent = player.health;
            playerAttackEl.textContent = player.attack;
            playerDefenseEl.textContent = player.defense;
            playerXPEl.textContent = player.xp;
            playerLevelEl.textContent = player.level;
            playerXEl.textContent = player.x;
            playerYEl.textContent = player.y;

            inventoryListEl.innerHTML = '';
            if (player.inventory.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'Пусто';
                inventoryListEl.appendChild(li);
            } else {
                player.inventory.forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = item.name;
                    inventoryListEl.appendChild(li);
                });
            }

            otherPlayersListEl.innerHTML = '';
            if (otherPlayers.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'Нет других игроков';
                otherPlayersListEl.appendChild(li);
            } else {
                otherPlayers.forEach(otherPlayer => {
                    const li = document.createElement('li');
                    li.textContent = `${otherPlayer.name} (Уровень ${otherPlayer.level}) - X:${otherPlayer.x}, Y:${otherPlayer.y}`;
                    otherPlayersListEl.appendChild(li);
                });
            }
        }

        /**
         * Draws the game state on the canvas.
         */
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            // Draw map tiles
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    // Ensure map[y] and map[y][x] exist before accessing
                    if (!map[y] || map[y][x] === undefined) {
                        console.warn(`Map tile at (${x}, ${y}) is undefined. Skipping draw.`);
                        continue; // Skip drawing this tile if it's undefined
                    }

                    const tileType = map[y][x];
                    let color = '#333'; // Default floor color
                    if (tileType === 'wall') {
                        color = '#666'; // Wall color
                    }
                    ctx.fillStyle = color;
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                    // Draw grid lines
                    ctx.strokeStyle = '#222';
                    ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }

            // Draw enemies
            enemies.forEach(enemy => {
                ctx.fillStyle = 'red'; // Enemy color
                // Draw enemies slightly smaller and centered
                ctx.fillRect(enemy.x * TILE_SIZE + TILE_SIZE / 4, enemy.y * TILE_SIZE + TILE_SIZE / 4, TILE_SIZE / 2, TILE_SIZE / 2);
            });

            // Draw other players
            otherPlayers.forEach(otherPlayer => {
                // Ensure we don't draw the current player as an "other player"
                if (otherPlayer.id === player.id) return;

                ctx.fillStyle = 'green'; // Other player color
                ctx.fillRect(otherPlayer.x * TILE_SIZE, otherPlayer.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                ctx.fillStyle = 'white';
                ctx.font = '10px Inter';
                ctx.fillText(otherPlayer.name, otherPlayer.x * TILE_SIZE, otherPlayer.y * TILE_SIZE - 5);
            });

            // Draw current player (using image or fallback to square)
            if (playerImage.isLoaded) { // Check if image is fully loaded
                ctx.drawImage(playerImage, player.x * TILE_SIZE, player.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            } else {
                // Fallback to drawing a blue square if image not loaded or failed
                ctx.fillStyle = 'blue';
                ctx.fillRect(player.x * TILE_SIZE, player.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
            ctx.fillStyle = 'white';
            ctx.font = '10px Inter';
            ctx.fillText(player.name, player.x * TILE_SIZE, player.y * TILE_SIZE - 5);
        }

        /**
         * Updates the current player's data in Supabase.
         */
        async function updatePlayerPositionInSupabase() {
            if (!gameReady || !supabase || !player.id) {
                console.warn("Game not ready, Supabase client not available, or player ID not set for update.");
                return;
            }
            try {
                const { data, error } = await supabase
                    .from('players')
                    .upsert({
                        id: player.id,
                        name: player.name,
                        x: player.x,
                        y: player.y,
                        health: player.health,
                        maxhealth: player.maxhealth, // <--- ИЗМЕНЕНО: maxHealth -> maxhealth
                        attack: player.attack,
                        defense: player.defense,
                        xp: player.xp,
                        level: player.level,
                        updated_at: new Date().toISOString() // Update timestamp
                    }, { onConflict: 'id' }); // Conflict on 'id' means update if exists, insert if not

                if (error) {
                    console.error("Ошибка записи данных игрока в Supabase:", error);
                    logMessage("Ошибка сохранения вашего прогресса.");
                } else {
                    // console.log("Player data saved to Supabase:", data);
                }
            } catch (e) {
                console.error("Исключение при записи данных игрока в Supabase:", e);
                logMessage("Ошибка сохранения вашего прогресса.");
            }
        }

        /**
         * Listens for real-time updates of other players from Supabase.
         */
        function listenForOtherPlayers() {
            if (!gameReady || !supabase || !player.id) {
                console.warn("Game not ready, Supabase client not available, or player ID not set for listening to other players.");
                return;
            }

            // Initial fetch of all players
            supabase
                .from('players')
                .select('*')
                .then(({ data, error }) => {
                    if (error) {
                        console.error("Ошибка при получении начальных данных игроков:", error);
                        logMessage("Ошибка загрузки начальных данных других игроков.");
                    } else {
                        otherPlayers = data.filter(p => p.id !== player.id);
                        drawGame();
                        updateUI();
                    }
                });

            // Real-time subscription for changes
            supabase
                .channel('players_changes') // You can name your channel
                .on('postgres_changes', { event: '*', schema: 'public', table: 'players' }, payload => {
                    // console.log('Change received!', payload);
                    if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
                        const changedPlayer = payload.new;
                        if (changedPlayer.id === player.id) {
                            // This is the current player's own update, ignore for otherPlayers list
                            return;
                        }
                        const existingIndex = otherPlayers.findIndex(p => p.id === changedPlayer.id);
                        if (existingIndex > -1) {
                            otherPlayers[existingIndex] = changedPlayer; // Update existing player
                        } else {
                            otherPlayers.push(changedPlayer); // Add new player
                        }
                    } else if (payload.eventType === 'DELETE') {
                        const deletedPlayerId = payload.old.id;
                        otherPlayers = otherPlayers.filter(p => p.id !== deletedPlayerId); // Remove deleted player
                    }
                    drawGame();
                    updateUI();
                })
                .subscribe();

            logMessage("Подписка на других игроков активна.");
        }

        /**
         * Handles player movement.
         * @param {number} dx - Change in X coordinate.
         * @param {number} dy - Change in Y coordinate.
         */
        async function movePlayer(dx, dy) {
            if (!gameReady) return;

            const newX = player.x + dx;
            const newY = player.y + dy;

            // Check bounds
            if (newX < 0 || newX >= MAP_WIDTH || newY < 0 || newY >= MAP_HEIGHT) {
                logMessage('Вы не можете идти в этом направлении.');
                return;
            }

            // Check for walls
            if (map[newY][newX] === 'wall') {
                logMessage('Стена блокирует ваш путь.');
                return;
            }

            // Check for enemies (local combat)
            const targetEnemy = getEnemyAt(newX, newY);
            if (targetEnemy) {
                logMessage(`Вы атакуете ${targetEnemy.name}!`);
                combat(player, targetEnemy);
                return; // Don't move if attacking
            }

            // If no obstacles, move the player
            player.x = newX;
            player.y = newY;
            logMessage(`Вы переместились на (${player.x}, ${player.y}).`);

            // Update player position in Supabase
            await updatePlayerPositionInSupabase();

            drawGame();
            updateUI();
        }

        /**
         * Handles combat between attacker and defender.
         * @param {object} attacker - The attacking entity (player or inemy).
         * @param {object} defender - The defending entity (player or enemy).
         */
        function combat(attacker, defender) {
            let damage = Math.max(0, attacker.attack - defender.defense);
            defender.health -= damage;
            logMessage(`${attacker.name} наносит ${damage} урона ${defender.name}.`);

            if (defender.health <= 0) {
                logMessage(`${defender.name} побежден!`);
                if (defender === player) {
                    logMessage('Вы были побеждены. Игра окончена!');
                    // Implement game over logic (e.g., reset game, show message)
                } else {
                    // Enemy defeated
                    player.xp += defender.xpValue;
                    logMessage(`Вы получили ${defender.xpValue} опыта.`);
                    // Remove enemy from the map and enemies array
                    map[defender.y][defender.x] = 'floor'; // Set tile back to floor
                    enemies = enemies.filter(e => e !== defender);
                    checkLevelUp();
                }
            } else {
                // If defender is still alive, they might retaliate (if it's turn-based)
                if (defender === player) {
                    // Player was attacked, no retaliation in this simple model yet
                } else {
                    // Enemy retaliates
                    logMessage(`${defender.name} отвечает!`);
                    combat(defender, attacker); // Enemy attacks player back
                }
            }
            drawGame();
            updateUI();
        }

        /**
         * Checks if the player has enough XP to level up.
         */
        function checkLevelUp() {
            const xpNeededForNextLevel = player.level * 50; // Simple XP curve
            if (player.xp >= xpNeededForNextLevel) {
                player.level++;
                player.xp -= xpNeededForNextLevel; // Carry over excess XP
                player.maxhealth += 10; // <--- ИЗМЕНЕНО: maxHealth -> maxhealth
                player.health = player.maxhealth; // Restore health on level up <--- ИЗМЕНЕНО: maxHealth -> maxhealth
                player.attack += 2;
                player.defense += 1;
                logMessage(`Поздравляем! Вы достигли уровня ${player.level}!`);
                updateUI();
                updatePlayerPositionInSupabase(); // Update stats in Supabase
            }
        }

        /**
         * Handles keyboard input for player movement.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleKeyDown(event) {
            switch (event.key) {
                case 'w':
                case 'ArrowUp':
                    movePlayer(0, -1);
                    break;
                case 's':
                case 'ArrowDown':
                    movePlayer(0, 1);
                    break;
                case 'a':
                case 'ArrowLeft':
                    movePlayer(-1, 0);
                    break;
                case 'd':
                case 'ArrowRight':
                    movePlayer(1, 0);
                    break;
            }
        }

        // Initialize Supabase and start game on window load
        window.onload = initializeSupabase;
    </script>
</body>
</html>
 
